{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"quicue-kg","text":"<p>CUE-native knowledge graph framework for tracking architectural decisions, patterns, insights, and rejected approaches \u2014 with compile-time validation.</p>"},{"location":"#why","title":"Why","text":"<p>Projects accumulate knowledge that lives outside source code: why a technology was chosen, what approaches failed, which patterns recur. This knowledge typically scatters across wikis, chat logs, and individual memory. When it's lost, teams re-explore failed paths and make decisions without context.</p> <p>quicue-kg stores this knowledge as typed CUE data in a <code>.kg/</code> directory alongside your code. CUE's type system enforces structure \u2014 every rejected approach must record an alternative, every insight must cite evidence. Validation is <code>cue vet .kg/</code>. No database, no server.</p> <p>Who this is for: Development teams who want queryable, validated project knowledge that lives in version control.</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code># Initialize a knowledge graph in your project\nkg init\n\n# Record a decision\nkg add decision\n# Edit the generated file, then validate\nkg vet\n\n# See what you've recorded\nkg index --summary\n</code></pre> <p>A minimal <code>.kg/</code> looks like this:</p> <pre><code>package kg\n\nimport \"quicue.ca/kg/core@v0\"\n\ndecisions: {\n    \"ADR-001\": core.#Decision &amp; {\n        id:           \"ADR-001\"\n        title:        \"Use PostgreSQL for persistence\"\n        status:       \"accepted\"\n        date:         \"2026-01-15\"\n        context:      \"Need ACID transactions and JSONB support.\"\n        decision:     \"Use PostgreSQL 16 with JSONB columns for semi-structured data.\"\n        rationale:    \"Mature ecosystem, strong JSONB performance, team expertise.\"\n        consequences: [\"All persistence goes through PostgreSQL\", \"No separate document store needed\"]\n    }\n}\n</code></pre> <p>CUE validates this at compile time: missing fields, invalid status values, and malformed IDs are all caught before commit.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>module: \"quicue.ca/kg@v0\"\n</code></pre> <p>Via GHCR (available now): <pre><code>export CUE_REGISTRY='quicue.ca=ghcr.io/quicue/cue-modules,registry.cue.works'\ncue mod tidy\n</code></pre></p> <p>Via local symlink (development): <pre><code>mkdir -p cue.mod/pkg/quicue.ca/kg\nln -s /path/to/quicue-kg/* cue.mod/pkg/quicue.ca/kg/\n</code></pre></p>"},{"location":"#what-makes-this-different","title":"What makes this different","text":"<p>CUE's type system gives properties that are hard to get from traditional knowledge management:</p> <ol> <li> <p>Knowledge conflicts are type errors. If two teams assert contradictory facts about the same decision, CUE unification fails at build time \u2014 not silently at read time.</p> </li> <li> <p>Federation without infrastructure. Merging knowledge across projects is a CUE import, not a service call. <code>cue vet</code> catches conflicts. No shared database needed.</p> </li> <li> <p>Progressive refinement. CUE's type lattice only narrows, never broadens. A field constrained to <code>\"high\" | \"medium\" | \"low\"</code> can't silently accept <code>\"maybe\"</code>. Evidence accumulates; it can't disappear.</p> </li> <li> <p>Schema evolution as a quality ratchet. Adding a required field to <code>#Decision</code> makes every existing entry without it a validation error. The schema enforces improvement.</p> </li> <li> <p>Computed indexes. Summary views (<code>by_status</code>, <code>by_confidence</code>) are CUE comprehensions over the data. They're always in sync because they're derived, never maintained.</p> </li> </ol>"},{"location":"#types","title":"Types","text":""},{"location":"#core-core","title":"Core (<code>core/</code>)","text":"Type ID Pattern Purpose <code>#Decision</code> <code>ADR-NNN</code> Architecture decisions with mandatory rationale and consequences <code>#Pattern</code> \u2014 Reusable problem/solution pairs with cross-project tracking <code>#Insight</code> <code>INSIGHT-NNN</code> Validated discoveries with mandatory evidence and confidence level <code>#Rejected</code> <code>REJ-NNN</code> Failed approaches \u2014 must record what to do instead"},{"location":"#extensions-ext","title":"Extensions (<code>ext/</code>)","text":"Type Purpose <code>#Derivation</code> Data pipeline audit trails tracking how outputs relate to source data <code>#Workspace</code> Multi-repo topology mapping <code>#Context</code> Project identity and self-description"},{"location":"#aggregation-aggregate","title":"Aggregation (<code>aggregate/</code>)","text":"Type Purpose <code>#KGIndex</code> Computed summary, by_status, by_confidence views <code>#KGLint</code> Structural quality checks <code>#Provenance</code> PROV-O projection (decisions as provenance activities) <code>#DatasetEntry</code> DCAT projection (project as cataloged dataset) <code>#FederatedCatalog</code> DCAT catalog for federation results <code>#Annotations</code> Web Annotation projection (insights and rejected as annotations) <code>#Prolog</code> Prolog facts + inference rules for logic programming <code>#Datalog</code> Souffl\u00e9-compatible Datalog (guaranteed termination) <code>#NTriples</code> N-Triples \u2014 one triple per line, greppable RDF <code>#Turtle</code> Turtle \u2014 human-readable prefixed RDF <code>#SKOSTaxonomy</code> SKOS concept scheme from pattern categories"},{"location":"#linked-data-logic-projections","title":"Linked Data &amp; Logic Projections","text":"<p>The knowledge graph exports to W3C vocabularies and logic programming formats via CUE comprehensions. These projections make your knowledge graph interoperable with linked data tools, triplestores, and logic engines without replacing CUE as the source of truth.</p>"},{"location":"#rdf-semantic-web","title":"RDF &amp; Semantic Web","text":"Projection Standard Use case Export expression Provenance PROV-O Decision audit trails <code>_provenance.graph</code> Catalog DCAT Data catalog registration <code>_catalog.dataset</code> Annotations Web Annotation Insight/rejected as annotations <code>_annotations.graph</code> N-Triples RDF 1.1 Bulk triplestore loading, grep/sort/diff <code>_ntriples.triples</code> Turtle RDF 1.1 Human-readable RDF, SPARQL endpoint import <code>_turtle.document</code> SKOS SKOS Pattern taxonomy as browsable concept scheme <code>_taxonomy.graph</code>"},{"location":"#logic-programming","title":"Logic Programming","text":"Projection Runtime Use case Export expression Prolog SWI-Prolog Inference rules, transitive provenance queries <code>_prolog.program</code> Datalog Souffl\u00e9 Guaranteed-terminating queries at scale <code>_datalog.program</code> <pre><code># Export decision audit trail as PROV-O JSON-LD\ncue export .kg/ -e _provenance.graph --out json\n\n# Register project in a data catalog\ncue export .kg/ -e _catalog.dataset --out json\n\n# Greppable RDF for unix pipelines\ncue export .kg/ -e _ntriples.triples --out text\n\n# Human-readable RDF for SPARQL endpoints\ncue export .kg/ -e _turtle.document --out text\n\n# Pattern taxonomy as SKOS JSON-LD\ncue export .kg/ -e _taxonomy.graph --out json\n\n# Logic programming (Prolog facts + inference rules)\ncue export .kg/ -e _prolog.program --out text\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<pre><code>Usage: kg &lt;command&gt; [args...]\n\nCommands:\n  init              Scaffold .kg/ directory with imports\n  add &lt;type&gt;        Create new entry (decision|pattern|insight|rejected)\n  vet               Validate .kg/ content\n  index [--full]    Export aggregated index as JSON\n  query &lt;expr&gt;      Query via CUE expression\n  lint              Knowledge quality checks\n  settle            Check for conflicts, coverage gaps, referential integrity\n  diff [ref]        Semantic changelog since git ref\n  link &lt;a&gt; &lt;b&gt;      Cross-reference two entries\n  graph [--dot]     Export relationships as JSON or DOT\n  fed &lt;dirs...&gt;     Federate multiple .kg/ directories\n</code></pre>"},{"location":"#specification","title":"Specification","text":"<p>The full specification (directory layout, type constraints, aggregation semantics, federation protocol) is published at quicue.github.io/quicue-kg/spec.html.</p> <p>JSON-LD vocabulary context: quicue.github.io/quicue-kg/context.jsonld</p>"},{"location":"#development","title":"Development","text":"<pre><code>make all          # Run all checks\nmake e2e          # End-to-end tests (schemas, exports, CLI, cross-repo)\nmake validate     # Validate schemas only\nmake test-valid   # Run valid test instances\nmake test-invalid # Confirm invalid instances are rejected\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Apache-2.0</p>"},{"location":"semantic-web/","title":"Semantic Web &amp; Linked Data","text":"<p>quicue exports infrastructure and knowledge as linked data across two layers: quicue.ca models what infrastructure is (resources, dependencies, operations), and quicue-kg captures why it exists (decisions, patterns, insights). Both export to W3C standard vocabularies. Together they form a semantic infrastructure platform where every resource and every decision is addressable, queryable, and machine-navigable.</p>"},{"location":"semantic-web/#two-layers-one-graph","title":"Two layers, one graph","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  quicue.ca \u2014 infrastructure modeling                     \u2502\n\u2502                                                          \u2502\n\u2502  vocab/context.cue     JSON-LD @context (quicue: IRIs)  \u2502\n\u2502  patterns/shacl.cue    SHACL shapes for validation       \u2502\n\u2502  ou/hydra.cue          Hydra API documentation           \u2502\n\u2502  ou/activitystreams.cue  AS2 infrastructure change feed  \u2502\n\u2502  examples/*/jsonld      JSON-LD infrastructure graph      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  quicue-kg \u2014 knowledge capture                           \u2502\n\u2502                                                          \u2502\n\u2502  aggregate/provenance.cue   PROV-O audit trails          \u2502\n\u2502  aggregate/catalog.cue      DCAT dataset registration    \u2502\n\u2502  aggregate/annotation.cue   Web Annotation insights      \u2502\n\u2502  aggregate/skos.cue         SKOS pattern taxonomy        \u2502\n\u2502  aggregate/turtle.cue       Turtle RDF export            \u2502\n\u2502  aggregate/ntriples.cue     N-Triples (greppable RDF)    \u2502\n\u2502  aggregate/prolog.cue       Prolog inference rules        \u2502\n\u2502  aggregate/datalog.cue      Datalog (guaranteed halt)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The layers share namespace wiring. <code>vocab/context.cue</code> already includes <code>prov:</code>, <code>dcat:</code>, <code>oa:</code>, <code>as:</code>, and <code>sh:</code> prefixes \u2014 both layers export to the same IRI space. A SPARQL query can join infrastructure state with the decisions that shaped it.</p>"},{"location":"semantic-web/#rdf-in-60-seconds","title":"RDF in 60 seconds","text":"<p>RDF stores data as triples: subject-predicate-object statements.</p> <pre><code>&lt;kg:ADR-001&gt;  &lt;rdf:type&gt;        &lt;kg:Decision&gt; .\n&lt;kg:ADR-001&gt;  &lt;rdfs:label&gt;      \"Use PostgreSQL\" .\n&lt;kg:ADR-001&gt;  &lt;prov:startedAt&gt;  \"2026-01-15\" .\n</code></pre> <p>Every fact is one triple. Triples compose \u2014 merge two datasets by concatenating them. Subjects and predicates are IRIs; objects are IRIs or literals. Any tool that speaks RDF (SPARQL endpoints, Oxigraph, Jena, rdflib) consumes this directly.</p>"},{"location":"semantic-web/#infrastructure-layer-quicueca","title":"Infrastructure layer (quicue.ca)","text":""},{"location":"semantic-web/#json-ld-infrastructure-graph","title":"JSON-LD infrastructure graph","text":"<p>Every infrastructure resource exports as a JSON-LD node with typed IRIs and semantic relationships:</p> <pre><code>cue export ./examples/datacenter/ -e jsonld --out json\n</code></pre> <p>This produces an <code>@graph</code> where each resource has <code>@type</code> arrays, <code>depends_on</code> as IRI references, and metadata (ip, host, container_id). The <code>@context</code> from <code>vocab/context.cue</code> maps CUE field names to <code>quicue:</code> namespace IRIs, making the graph dereferenceable.</p>"},{"location":"semantic-web/#shacl-shapes-patternsshaclcue","title":"SHACL shapes (<code>patterns/shacl.cue</code>)","text":"<p>SHACL (Shapes Constraint Language) validates RDF data the way CUE validates CUE data. <code>patterns/shacl.cue</code> generates <code>sh:NodeShape</code> definitions from the type registry:</p> <ul> <li>A base <code>quicue:ResourceShape</code> validates the generic resource structure</li> <li>Type-specific shapes (DNSServer, LXCContainer, Router, etc.) add property constraints: datatypes, cardinality, value restrictions</li> </ul> <pre><code>cue export -e shapes.graph --out json &gt; shapes.jsonld\n</code></pre> <p>These shapes can validate infrastructure RDF in any SHACL processor \u2014 useful for external consumers who receive your JSON-LD exports and want to check them without CUE.</p>"},{"location":"semantic-web/#hydra-api-ouhydracue","title":"Hydra API (<code>ou/hydra.cue</code>)","text":"<p>The Hydra Core Vocabulary makes APIs self-describing. <code>ou/hydra.cue</code> generates a <code>hydra:ApiDocumentation</code> where:</p> <ul> <li>Each resource type becomes a <code>hydra:Class</code> with <code>supportedOperation</code> (available actions) and <code>supportedProperty</code> (dependency links)</li> <li>Operations carry metadata: HTTP method, provider, action name, idempotent/destructive flags</li> <li>Navigation follows IRI links \u2014 clients discover operations by traversing the graph</li> </ul> <p>The imperator frontend (<code>imp.quicue.ca</code>) consumes this to render an interactive explorer. The API at <code>api.quicue.ca</code> serves it as <code>application/ld+json</code>.</p> <pre><code>cue export ./examples/datacenter/ -e datacenter_hydra --out json\n</code></pre>"},{"location":"semantic-web/#activitystreams-20-ouactivitystreamscue","title":"ActivityStreams 2.0 (<code>ou/activitystreams.cue</code>)","text":"<p>Maps operator sessions to ActivityStreams 2.0 for infrastructure change feeds:</p> Action category AS2 activity type deploy <code>as:Create</code> lifecycle <code>as:Update</code> monitoring, diagnostic <code>as:View</code> shutdown <code>as:Delete</code> <p>Output is an <code>as:OrderedCollection</code> of activities, each with actor (operator role), object (resource), and instrument (provider/action). Feed subscribers get a machine-readable change log.</p> <pre><code>cue export -e feed.stream --out json\n</code></pre>"},{"location":"semantic-web/#knowledge-layer-quicue-kg","title":"Knowledge layer (quicue-kg)","text":""},{"location":"semantic-web/#projection-architecture","title":"Projection architecture","text":"<p>All kg projections live in <code>aggregate/</code> and share the same input contract:</p> <pre><code>#SomeProjection: {\n    index: #KGIndex          // Input: the computed index\n    graph: { ... }            // Output: structured data\n    summary: { ... }          // Metadata: counts, stats\n}\n</code></pre> <p>CUE comprehensions iterate over the index and emit structured output. Projections are one-way: CUE <code>.kg/</code> files are the source of truth. You never edit the RDF \u2014 you edit CUE and re-export.</p>"},{"location":"semantic-web/#rdf-serializations","title":"RDF serializations","text":"<p>Three wire formats for the same RDF data model:</p> Format Type Best for N-Triples <code>#NTriples</code> <code>grep</code>, <code>sort</code>, <code>diff</code>, bulk triplestore loading Turtle <code>#Turtle</code> Human reading, SPARQL endpoint import JSON-LD <code>#Provenance</code> Web APIs, browser consumption <pre><code># Greppable RDF \u2014 one triple per line, fully expanded IRIs\ncue export .kg/ -e _ntriples.triples --out text | grep 'prov#Activity'\n\n# Human-readable RDF with prefixes\ncue export .kg/ -e _turtle.document --out text\n\n# JSON-LD for web consumption\ncue export .kg/ -e _provenance.graph --out json\n</code></pre>"},{"location":"semantic-web/#semantic-vocabularies","title":"Semantic vocabularies","text":"Projection Standard Purpose Export PROV-O W3C Provenance Decision audit trails <code>_provenance.graph</code> DCAT Data Catalog Project catalog registration <code>_catalog.dataset</code> Web Annotation W3C Annotation Insights as annotations <code>_annotations.graph</code> SKOS Knowledge Org Pattern taxonomy <code>_taxonomy.graph</code> <p>SKOS maps pattern categories to <code>skos:Concept</code> top concepts and patterns to narrower concepts:</p> <pre><code>cue export .kg/ -e _taxonomy.graph --out json   # JSON-LD\ncue export .kg/ -e _taxonomy.turtle --out text   # Turtle\n</code></pre>"},{"location":"semantic-web/#logic-programming","title":"Logic programming","text":"<p>Facts + inference rules make knowledge computable:</p> Projection Runtime Terminates? Prolog SWI-Prolog No (Turing-complete) Datalog Souffl\u00e9 Yes (guaranteed) <p>Both include 6 inference rules: transitive provenance (<code>contributed</code>), trust levels, authority ranking, shared patterns, active decisions, and actionable insights.</p> <pre><code># Prolog \u2014 interactive exploration\ncue export .kg/ -e _prolog.program --out text &gt; kb.pl\nswipl -l kb.pl -g \"shared_pattern(P, A, B), format('~w: ~w + ~w~n', [P, A, B]), fail.\"\n\n# Datalog \u2014 guaranteed termination, compiles to C++\ncue export .kg/ -e _datalog.program --out text &gt; kb.dl\nsouffle kb.dl\n</code></pre> <p>Prolog vs Datalog: Use Prolog for recursive queries and interactive exploration. Use Datalog for CI automation and large datasets (Souffl\u00e9 compiles to native code).</p>"},{"location":"semantic-web/#how-the-layers-connect","title":"How the layers connect","text":"<p>The infrastructure graph and knowledge graph share the same IRI space. This means you can query across both:</p> <pre><code># SPARQL: find decisions about resources with &gt; 3 dependencies\nPREFIX kg: &lt;https://quicue.ca/kg#&gt;\nPREFIX quicue: &lt;https://quicue.ca/vocab#&gt;\nPREFIX prov: &lt;http://www.w3.org/ns/prov#&gt;\n\nSELECT ?decision ?resource ?deps WHERE {\n  ?decision a kg:Decision ; prov:startedAtTime ?date .\n  ?resource quicue:depends_on ?dep .\n}\nGROUP BY ?decision ?resource\nHAVING (COUNT(?dep) &gt; 3)\n</code></pre> <p>The integration points:</p> quicue.ca produces kg consumes/extends JSON-LD infrastructure graph PROV-O ties decisions to resources SHACL shapes for types SKOS taxonomy for patterns ActivityStreams change feed Provenance chains for audit Hydra API documentation DCAT registers the project as a dataset <p><code>vocab/context.cue</code> is the bridge \u2014 it defines both <code>quicue:</code> (infrastructure) and <code>kg:</code> (knowledge) namespace mappings, plus all W3C vocabulary prefixes. Both layers import it.</p>"},{"location":"semantic-web/#choosing-a-format","title":"Choosing a format","text":"I want to... Use Describe infrastructure resources as linked data JSON-LD graph (quicue.ca) Validate infrastructure RDF externally SHACL shapes (quicue.ca) Self-describing API for frontends Hydra (quicue.ca) Feed infrastructure changes to subscribers ActivityStreams (quicue.ca) Decision audit trails PROV-O (kg) Load into a triplestore Turtle or N-Triples (kg) Process with unix tools N-Triples (kg) Browse patterns as taxonomy SKOS (kg) Query provenance chains Prolog or Datalog (kg) Automated CI checks Datalog (kg) Register in a data catalog DCAT (kg)"},{"location":"semantic-web/#namespaces","title":"Namespaces","text":"Prefix IRI Layer Vocabulary <code>quicue:</code> <code>https://quicue.ca/vocab#</code> Infrastructure Resource types, fields, actions <code>kg:</code> <code>https://quicue.ca/kg#</code> Knowledge Decisions, patterns, insights <code>prov:</code> <code>http://www.w3.org/ns/prov#</code> Both Provenance <code>dcat:</code> <code>http://www.w3.org/ns/dcat#</code> Both Data catalog <code>oa:</code> <code>http://www.w3.org/ns/oa#</code> Knowledge Annotations <code>skos:</code> <code>http://www.w3.org/2004/02/skos/core#</code> Knowledge Taxonomy <code>sh:</code> <code>http://www.w3.org/ns/shacl#</code> Infrastructure Shape validation <code>hydra:</code> <code>http://www.w3.org/ns/hydra/core#</code> Infrastructure API description <code>as:</code> <code>https://www.w3.org/ns/activitystreams#</code> Infrastructure Activity feeds <code>dcterms:</code> <code>http://purl.org/dc/terms/</code> Both Dublin Core metadata <code>rdfs:</code> <code>http://www.w3.org/2000/01/rdf-schema#</code> Both RDF Schema <p>JSON-LD contexts: quicue.ca/vocab (infrastructure) | kg.quicue.ca/context.jsonld (knowledge)</p>"},{"location":"specification/","title":"Specification","text":"<p>The full quicue-kg specification covers directory layout, type constraints, aggregation semantics, W3C projection mappings, and the federation protocol.</p> <p>Read the specification \u2192</p> <p>The specification is a W3C-style ReSpec document covering:</p> <ul> <li>Core types \u2014 <code>#Decision</code>, <code>#Pattern</code>, <code>#Insight</code>, <code>#Rejected</code> with validation rules</li> <li>Extension types \u2014 <code>#Derivation</code>, <code>#Workspace</code>, <code>#Context</code>, <code>#SourceFile</code>, <code>#CollectionProtocol</code>, <code>#PipelineRun</code></li> <li>Aggregation \u2014 <code>#KGIndex</code> computed views, <code>#KGLint</code> quality checks</li> <li>W3C projections \u2014 PROV-O, Web Annotation, DCAT, N-Triples, Turtle, SKOS, Prolog, Datalog</li> <li>Federation protocol \u2014 Cross-project discovery, merge semantics, conflict detection</li> <li>JSON-LD context \u2014 Namespace mappings and RDFS class hierarchy</li> </ul>"},{"location":"specification/#json-ld-context","title":"JSON-LD Context","text":"<p>The <code>kg:</code> namespace resolves to <code>https://quicue.ca/kg#</code>. The vocabulary context is available at:</p> <ul> <li>Machine-readable: context.jsonld</li> <li>Source: <code>vocab/context.cue</code> in the repository</li> </ul>"}]}